{% extends 'layout.html' %}

{% block css %}
<link href="{{ url_for('static', filename='css/home.css') }}" rel="stylesheet">
{% endblock %}

{% block content %}

<div class="container">
  <h1>Documentation</h1>

  <h2>Morae</h2>

  <p>If a character is a yo'on ("ゃ", "ゅ", "ょ", "ぁ", "ぃ", "ぇ", "ゎ") then attach to the previous character.
    <ul>
      <li>き + ゃ → きゃ
	</ul>
   


  <p>Code is in <code>utils.py</code>
  
  <h2>Syllables</h2>

  <ul>
    <li> Any mora followed by "ん" or  "っ" joins to that.
    <ul>
      <li>こ + ん → こん
      <li>き + っ → きっ
    </ul>
  <li> A mora ending in /a/ ('あ',  'か', 'が', 'きゃ', 'ぎゃ', ...)
    followed by a mora "あ", "い", "う" or "ー"
    <ul>
      <li>か + い → かい
      <li>あ + いん → あ + いん (ん joins first)
    </ul>
  <li> A mora ending in /i/ 
    followed by a mora "い" or "ー"
    <ul>
      <li>き + い → きい
    </ul>
  <li> A mora ending in /u/
    followed by a mora 'う'
    <ul>
      <li>く + う → くう
    </ul>
  <li> A mora ending in /e/ 
    followed by a mora  "い", "え" or "ー"
    <ul>
      <li>て + い →てい
      <li>て + え → てえ
    </ul>
  <li> A mora ending in /o/  followed by a mora "お", "う" or "ー"
    <ul>
      <li>と + う → とう
      <li>お + お → おお
    </ul>
</ul>
    
<p>It is not possible to determine syllable boundaries just from a
kana string.  We will always join when we can, starting from the
front.  Something like "みい" could be "み" + "い" or "みい", we will always produce "みい". Something like "とおう" could be "と" + "おう" or "とお" + "う", will produce the latter.

<p>Normally Japanese syllables only have two mora, but we have names like 'ろおい', which is probably intended to be pronounced like <i>Roy</i> which would be one syllable.  We currently treat this as two: 'ろお' + 'い'



  <p>Code is in <code>utils.py</code>


    <h2>Counting first and last features</h2>

    <p>If we look for a feature in the first or last position, then we only do this if there are two or more. (char1, char_1, mora1, mora_1, syl1, syll_1)

    <p>If the feature is the last two, then we only do this if there are three or more.
 (char_2, mora_2, syll_2)

      <h2>Data</h2>

      <h3>Heisei Data</h3>

    <p>When we load the data from the Heisei Namae Jiten, we clean it in three ways (see <code>add-heisei.py</code>)
      <ul>
	<li>Map some old characters to new characters e.g. '莱' to '萊'.
	We only do these for 9 characters which appear in the data
	  often, as well as variant lengtheners ('―' to 'ー')
	<li>We only keep words that are composed entirely of Jinmeiyo
	  Kanji, Joyo Kanji, the iterator ('々'), Katakana or Hiragana (only these are legal Japanese names).
	  <br> So we reject names like: 人, 痲綾, 幸太Ｃ or チャン赫
	  <br>There is a nice site for checking these <a href='joyokanjikai.com'>Joyo Kanji Kai</a>, we used their lists of Joyo/Jinmeiyo kanji
	<li>If a word consists only of kanji and the iterator, but is
	longer than 5 characters we reject it as it is almost
	certainly a surname+firstname entered incorrectly.
	  <br> So we reject names like: 九郎右衛門, 阿社茉利奈, 玲奈加奈子
      </ul>

    <p>This is fewer than 1% of the types (0.34%) and much less than
    that of the individual names (0.049%)
    
      <pre>
## Statistics

good	type	1512879
good	token	14534080
reject	type	4994
reject	token	6936
remap	type	121
remap	token	154
long	type	46
long	token	46
      </pre>


<>

<p>Information on the licenses for the data can be found here: <a href='https://github.com/bond-lab/namae-bc/blob/main/ATTRIBUTIONS.md'>https://github.com/bond-lab/namae-bc/blob/main/ATTRIBUTIONS.md</a>
  
{% endblock %}

